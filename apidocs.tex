\documentclass{article}

\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{amsmath}

\definecolor{officegreen}{rgb}{0, 0.5, 0}
\definecolor{navy}{rgb}{0, 0, 0.5}
\definecolor{linecolor}{rgb}{0.5, 0.6875, 0.6875}
\definecolor{outputcolor}{rgb}{0.375, 0.375, 0.375}

\newcommand{\id}[1]{\textcolor{black}{#1}}
\newcommand{\com}[1]{\textcolor{officegreen}{#1}}
\newcommand{\inact}[1]{\textcolor{gray}{#1}}
\newcommand{\kwd}[1]{\textcolor{navy}{#1}}
\newcommand{\num}[1]{\textcolor{officegreen}{#1}}
\newcommand{\ops}[1]{\textcolor{purple}{#1}}
\newcommand{\prep}[1]{\textcolor{purple}{#1}}
\newcommand{\str}[1]{\textcolor{olive}{#1}}
\newcommand{\lines}[1]{\textcolor{linecolor}{#1}}
\newcommand{\fsi}[1]{\textcolor{outputcolor}{#1}}
\newcommand{\omi}[1]{\textcolor{gray}{#1}}

% Overriding color and style of line numbers
\renewcommand{\theFancyVerbLine}{
\lines{\small \arabic{FancyVerbLine}:}}

\lstset{%
  backgroundcolor=\color{gray!15},
  basicstyle=\ttfamily,
  breaklines=true,
  columns=fullflexible
}

\title{{page-title}}
\date{}

\begin{document}

\maketitle




\href{https://mybinder.org/v2/gh/fsprojects/fsharp.formatting/gh-pages?filepath=apidocs.ipynb}{\begin{figure}[htbp]\centering
\includegraphics[width=1.0\textwidth]{img/badge-binder.svg}
\caption{Binder}
\end{figure}
} 
\href{https://fsprojects.github.io/FSharp.Formatting//apidocs.fsx}{\begin{figure}[htbp]\centering
\includegraphics[width=1.0\textwidth]{img/badge-script.svg}
\caption{Script}
\end{figure}
} 
\href{https://fsprojects.github.io/FSharp.Formatting//apidocs.ipynb}{\begin{figure}[htbp]\centering
\includegraphics[width=1.0\textwidth]{img/badge-notebook.svg}
\caption{Notebook}
\end{figure}
}
\section*{API Documentation Generation}



The \href{commandline.html}{command-line tool \texttt{fsdocs}} can be used to generate documentation
for F\# libraries with XML comments.  The documentation is normally built using \texttt{fsdocs build} and developed using \texttt{fsdocs watch}. For
the former the output will be placed in \texttt{output{\textbackslash}reference} by default.
\subsection*{Selected projects}



\texttt{fsdocs} automatically selects the projects and "cracks" the project files for information
\begin{itemize}
\item Projects with \texttt{GenerateDocumentationFile} and without \texttt{IsTestProject} are selected.

\item If Projects use \texttt{TargetFrameworks} (not \texttt{TargetFramework}, singular) only the first target framework will be used to build the docs.

\end{itemize}

\begin{lstlisting}
    <PropertyGroup>
      <GenerateDocumentationFile>true</GenerateDocumentationFile>
    </PropertyGroup>

\end{lstlisting}
\subsection*{Templates}



The HTML is built by instantiating a template. The template used is the first of:
\begin{itemize}
\item 

\texttt{docs/reference/\_template.html}

\item 

\texttt{docs/\_template.html}

\item 

The default template

\end{itemize}



Usually, the same template can be used as for \href{content.html}{other content}.
\subsection*{Classic XML Doc Comments}



XML Doc Comments may use \href{https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/}{the normal F\# and C\# XML doc standards}.


The tags that form the core of the XML doc specification are:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
{<}\id{c}{>}	{<}\id{para}{>}	{<}\id{see}{>}{*}	{<}\id{value}{>}
{<}\id{code}{>}	{<}\id{param}{>}{*}	{<}\id{seealso}{>}{*}
{<}\id{example}{>}	{<}\id{paramref}{>}	{<}\id{summary}{>}
{<}\kwd{exception}{>}{*}	{<}\id{permission}{>}{*}	{<}\id{typeparam}{>}{*}
{<}\id{include}{>}{*}	{<}\id{remarks}{>}	{<}\id{typeparamref}{>}
{<}\id{list}{>}	{<}\id{inheritdoc}{>}	{<}\id{returns}{>}


\end{lstlisting}



In addition, you may also use the \href{https://github.com/fsharp/fslang-design/blob/master/tooling/FST-1031-xmldoc-extensions.md}{Recommended XML doc extensions for F\# documentation tooling}.
\begin{itemize}
\item 

\texttt{<a href = "...">} links

\item 

Arbitrary paragraph-level HTML such as \texttt{<b>} for bold in XML doc text

\item 

\texttt{<namespacedoc>} giving documentation for the enclosing namespace

\item 

\texttt{<exclude/>} to exclude from XML docs

\item 

\texttt{<category>} to give a category for an entity or member. An optional \texttt{index} attribute can be specified
to help sort the list of categories.

\item 

\texttt{{\textbackslash}(...{\textbackslash})} for inline math and \texttt{\$\$...\$\$} and \texttt{{\textbackslash}[...{\textbackslash}]}for math environments, see \href{http://docs.mathjax.org.
Some}{http://docs.mathjax.org.
Some} escaping of characters (e.g. \texttt{<}, \texttt{>}) may be needed to form valid XML

\end{itemize}



An example of an XML documentation comment, assuming the code is in the namespace \texttt{TheNamespace}:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// <summary>}
\com{///   A module}
\com{/// </summary>}
\com{///}
\com{/// <namespacedoc>}
\com{///   <summary>A namespace to remember</summary>}
\com{///}
\com{///   <remarks>More on that</remarks>}
\com{/// </namespacedoc>}
\com{///}
\kwd{module} \ltyp{SomeModule} \ops{=}
    \com{/// <summary>}
    \com{///   Some actual comment}
    \com{///   <para>Another paragraph, see  <see cref="T:TheNamespace.SomeType"/>. </para>}
    \com{/// </summary>}
    \com{///}
    \com{/// <param name="x">The input</param>}
    \com{///}
    \com{/// <returns>The output</returns>}
    \com{///}
    \com{/// <example>}
    \com{///   Try using}
    \com{///   <code>}
    \com{///      open TheNamespace}
    \com{///      SomeModule.a}
    \com{///   </code>}
    \com{/// </example>}
    \com{///}
    \com{/// <category>Foo</category>}
    \kwd{let} \lfun{someFunction} \lfun{x} \ops{=} \num{42} \ops{+} \lfun{x}

\com{/// <summary>}
\com{///   A type, see  <see cref="T:TheNamespace.SomeModule"/> and}
\com{///  <see cref="M:TheNamespace.SomeModule.someFunction"/>.}
\com{/// </summary>}
\com{///}
\kwd{type} \ltyp{SomeType}{(}{)} \ops{=}
    \kwd{member} \lfun{x}{.}{P} \ops{=} \num{1}

\end{lstlisting}



Like types, members are referred to by xml doc sig.  These must currently be precise as the F\#
compiler doesn't elaborate these references from simpler names:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\kwd{type} \ltyp{Class2}{(}{)} \ops{=}
    \kwd{member} \lfun{this}{.}{Property} \ops{=} \str{"more"}
    \kwd{member} \lfun{this}{.}\lfun{Method0}{(}{)} \ops{=} \str{"more"}
    \kwd{member} \lfun{this}{.}\lfun{Method1}{(}\lfun{c}{:} \ltyp{string}{)} \ops{=} \str{"more"}
    \kwd{member} \lfun{this}{.}\lfun{Method2}{(}\lfun{c}{:} \ltyp{string}{,} \lfun{o}{:} \ltyp{obj}{)} \ops{=} \str{"more"}

\com{/// <see cref="P:TheNamespace.Class2.Property" />}
\com{/// and <see cref="M:TheNamespace.Class2.OtherMethod0" />}
\com{/// and <see cref="M:TheNamespace.Class2.Method1(System.String)" />}
\com{/// and <see cref="M:TheNamespace.Class2.Method2(System.String,System.Object)" />}
\kwd{let} \lfun{referringFunction1} {(}{)} \ops{=} \str{"result"}

\end{lstlisting}



Generic types are referred to by .NET compiled name, e.g.
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\kwd{type} \ltyp{GenericClass2}{<}{'}\id{T}{>}{(}{)} \ops{=}
    \kwd{member} \lfun{this}{.}{Property} \ops{=} \str{"more"}

    \kwd{member} \lfun{this}{.}\lfun{NonGenericMethod}{(}\id{\_c}{:} {'}\id{T}{)} \ops{=} \str{"more"}

    \kwd{member} \lfun{this}{.}\lfun{GenericMethod}{(}\id{\_c}{:} {'}\id{T}{,} \id{\_o}{:} {'}\id{U}{)} \ops{=} \str{"more"}

\com{/// See <see cref="T:TheNamespace.GenericClass2`1" />}
\com{/// and <see cref="P:TheNamespace.GenericClass2`1.Property" />}
\com{/// and <see cref="M:TheNamespace.GenericClass2`1.NonGenericMethod(`0)" />}
\com{/// and <see cref="M:TheNamespace.GenericClass2`1.GenericMethod``1(`0,``0)" />}
\kwd{let} \lfun{referringFunction2} {(}{)} \ops{=} \str{"result"}

\end{lstlisting}

\subsubsection*{Cross-referencing with <seealso>}



Use \texttt{<seealso cref="..."/>} within \texttt{<summary>} to create cross-references.


For example:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\kwd{module} \ltyp{Forest} \ops{=}

    \com{/// <summary>}
    \com{/// Find at most <c>limit</c> foxes in current forest}
    \com{///}
    \com{/// See also: <seealso cref="M:App.Forest.findSquirrels(System.Int32)"/>}
    \com{/// </summary>}
    \kwd{let} \lfun{findFoxes} {(}\lfun{limit} {:} \ltyp{int}{)} \ops{=} {[}{]}

    \com{/// <summary>}
    \com{/// Find at most <c>limit</c> squirrels in current forest}
    \com{///}
    \com{/// See also: <seealso cref="M:App.Forest.findFoxes(System.Int32)"/>}
    \com{/// </summary>}
    \kwd{let} \lfun{findSquirrels} {(}\lfun{limit} {:} \ltyp{int}{)} \ops{=} {[}{]}

\end{lstlisting}



You can find the correct value for \texttt{cref} in the generated \texttt{.xml} documentation file (this will be generated alongside the assembly's \texttt{.dll}`).


You can also omit the \texttt{cref}'s arguments, and \texttt{fsdocs} will make an attempt to find the first member that matches.


For example:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
    \com{/// See also: <seealso cref="M:App.Forest.findSquirrels"/>}


\end{lstlisting}



If the member cannot be found, a link to the containing module/type will be used instead.
\subsubsection*{Classic XMl Doc Comments: Excluding APIs from the docs}



If you want to exclude modules or functions from the API docs, you can use the \texttt{<exclude/>} tag.
It needs to be set on a separate triple-slashed line, and can either appear on its own or as part
of an existing \texttt{<summary>} (for example, you may wish to hide existing documentation while it's in progress).
The \texttt{<exclude/>} tag can be the first or last line in these cases.


Some examples:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// <exclude/>}
\kwd{module} \ltyp{BottleKids1} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{42}

\com{// Ordinary comment}
\com{/// <exclude/>}
\kwd{module} \ltyp{BottleKids2} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{43}

\com{/// <exclude/>}
\com{/// BottleKids3 provides improvements over BottleKids2}
\kwd{module} \ltyp{BottleKids3} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{44}

\com{/// BottleKids4 implements several new features over BottleKids3}
\com{/// <exclude/>}
\kwd{module} \ltyp{BottleKids4} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{45}

\com{/// <exclude/>}
\com{/// <summary>}
\com{/// BottleKids5 is all you'll ever need in terms of bottles or kids.}
\com{/// </summary>}
\kwd{module} \ltyp{BottleKids5} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{46}

\end{lstlisting}



Note that the comments for \texttt{BottleKids3} (and \texttt{BottleKids4}) will generate a warning. This is because
the \texttt{<exclude/>} tag will be parsed as part of the \texttt{summary} text, and so the documentation generator
can't be completely sure you meant to exclude the item, or whether it was a valid part of the documentation.
It will assume the exclusion was intended, but you may want to use explicit \texttt{<summary>} tags to remove
the warning.


The warning will be of the following format:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\id{Warning}{:} \id{detected} \str{"<exclude/>"} \kwd{in} \id{text} \kwd{of} \str{"<summary>"} \kwd{for} \str{"M:YourLib.BottleKids4"}{.} \id{Please} \id{see} \id{https}{:}\com{//fsprojects.github.io/FSharp.Formatting/apidocs.html\#Classic-XML-Doc-Comments}


\end{lstlisting}



You will find that \texttt{[omit]} also works, but is considered part of the Markdown syntax and is
deprecated for XML Doc comments. This will also produce a warning, such as this:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\id{The} \kwd{use} \kwd{of} \id{`}{[}\id{omit}{]}\id{`} \kwd{and} \id{other} \id{commands} \kwd{in} \id{XML} \id{comments} \id{is} \id{deprecated}{,} \id{please} \kwd{use} \id{XML} \id{extensions}{,} \id{see} \id{https}{:}\com{//github.com/fsharp/fslang-design/blob/master/tooling/FST-1031-xmldoc-extensions.md}


\end{lstlisting}

\subsection*{Go to Source links}



'fsdocs' normally automatically adds GitHub links to each functions, values and class members for further reference.


This is normally done automatically based on the following settings:
\begin{lstlisting}
    <RepositoryUrl>https://github.com/...</RepositoryUrl>
    <RepositoryBranch>...</RepositoryBranch>
    <RepositoryType>git</RepositoryType>

\end{lstlisting}


If your source is not built from the same project where you are building documentation then
you may need these settings:
\begin{lstlisting}
    <FsDocsSourceRepository>...</FsDocsSourceRepository> -- the URL for the root of the source
    <FsDocsSourceFolder>...</FsDocsSourceFolder>         -- the root soure folder at time of build

\end{lstlisting}


It is assumed that \texttt{sourceRepo} and \texttt{sourceFolder} have synchronized contents.
\subsection*{Markdown Comments}



You can use Markdown instead of XML in \texttt{///} comments. If you do, you should set \texttt{<UsesMarkdownComments>true</UsesMarkdownComments>} in
your F\# project file.
\begin{quote}


Note: Markdown Comments are not supported in all F\# IDE tooling.
\end{quote}

\subsubsection*{Adding cross-type links to modules and types in the same assembly}



You can automatically add cross-type links to the documentation pages of other modules and types in the same assembly.
You can do this in two different ways:
\begin{itemize}
\item 

Add a \href{https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\#links}{markdown inline link} were the link
title is the name of the type you want to link.
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// This will generate a link to [Foo.Bar] documentation}


\end{lstlisting}


\item 

Add a \href{https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet\#code}{Markdown inline code} (using
back-ticks) where the code is the name of the type you want to link.
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// This will also generate a link to `Foo.Bar` documentation}


\end{lstlisting}


\end{itemize}



You can use either the full name (including namespace and module) or the simple name of a type.
If more than one type is found with the same name, the link will not be generated.
If a type with the given name is not found in the same assembly, the link will not be generated.
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// Contains two types [Bar] and [Foo.Baz]}
\kwd{module} \ltyp{Foo} \ops{=}

    \com{/// Bar is just an `int` and belongs to module [Foo]}
    \kwd{type} \ltyp{Bar} \ops{=} \ltyp{int}

    \com{/// Baz contains a `Foo.Bar` as its `id`}
    \kwd{type} \ltyp{Baz} \ops{=} {\{} {id}{:} \ltyp{Bar} {\}}

    \com{/// This function operates on `Baz` types.}
    \kwd{let} \lfun{f} {(}\lfun{b}{:} \ltyp{Baz}{)} \ops{=} \lfun{b}{.}\id{id} \ops{*} \num{42}

\com{/// Referencing [Foo3] will not generate a link as there is no type with the name `Foo3`}
\kwd{module} \ltyp{Foo3} \ops{=}

    \com{/// This is not the same type as `Foo.Bar`}
    \kwd{type} \ltyp{Bar} \ops{=} \ltyp{double}

    \com{/// Using the simple name for [Bar] will fail to create a link because the name is duplicated in}
    \com{/// [Foo.Bar] and in [Foo3.Bar]. In this case, using the full name works.}
    \kwd{let} \lfun{f2} \lfun{b} \ops{=} \lfun{b} \ops{*} \num{50}

\end{lstlisting}

\subsubsection*{Markdown Comments: Excluding APIs from the docs}



If you want to exclude modules or functions from the API docs you can use the \texttt{[omit]} tag.
It needs to be set on a separate triple-slashed line, but it could be either the first or the last:


Example as last line:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// Some actual comment}
\com{/// [omit]}
\kwd{module} \ltyp{Bar} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{42}

\end{lstlisting}



Example as the first line:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\com{/// [omit]}
\com{/// Some actual comment}
\kwd{module} \ltyp{Bar2} \ops{=}
    \kwd{let} \id{a} \ops{=} \num{42}

\end{lstlisting}

\subsection*{Building library documentation programmatically}



You can build library documentation programmatically using the functionality
in the \href{https://fsprojects.github.io/FSharp.Formatting/reference/fsharp-formatting-apidocs-apidocs.html}{ApiDocs} type. To do this, load the assembly and open the necessary namespaces:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\prep{\#r} \str{"FSharp.Formatting.ApiDocs.dll"}

\kwd{open} \id{FSharp}{.}\id{Formatting}{.}\id{ApiDocs}
\kwd{open} \id{System}{.}\id{IO}

\end{lstlisting}



For example the \href{https://fsprojects.github.io/FSharp.Formatting/reference/fsharp-formatting-apidocs-apidocs.html\#GenerateHtml}{ApiDocs.GenerateHtml} method:
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\kwd{let} \id{file} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"bin/YourLibrary.dll"}{)}

\kwd{let} \id{input} \ops{=} \ltyp{ApiDocInput}{.}\id{FromFile}{(}\id{file}{)}

\ltyp{ApiDocs}{.}\id{GenerateHtml}{(}
    {[} \id{input} {]}{,}
    \lfun{output} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"output"}{)}{,}
    \lfun{collectionName} \ops{=} \str{"YourLibrary"}{,}
    \lfun{template} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"templates"}{,} \str{"template.html"}{)}{,}
    \lfun{substitutions} \ops{=} {[}{]}
{)}

\end{lstlisting}

\subsubsection*{Adding extra dependencies}



When building a library programmatically, you might require a reference to an additional assembly.
You can pass this using the \texttt{otherFlags} argument.
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\kwd{let} \id{projectAssembly} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"bin/X.dll"}{)}

\kwd{let} \id{projectInput} \ops{=} \ltyp{ApiDocInput}{.}\id{FromFile}{(}\id{projectAssembly}{)}

\ltyp{ApiDocs}{.}\id{GenerateHtml}{(}
    {[} \id{projectInput} {]}{,}
    \lfun{output} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"output"}{)}{,}
    \lfun{collectionName} \ops{=} \str{"Project X"}{,}
    \lfun{template} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"templates"}{,} \str{"template.html"}{)}{,}
    \lfun{substitutions} \ops{=} {[}{]}{,}
    \lfun{otherFlags} \ops{=} {[} \str{"-r:/root/ProjectY/bin/Debug/net6.0/Y.dll"} {]}
{)}

\end{lstlisting}



or use \texttt{libDirs} to include all assemblies from an entire folder.
Tip: A combination of \texttt{<CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>} in the fsproj file and setting \texttt{libDirs} to the compilation output path leads to only one folder with all dependencies referenced.
This might be easier, especially for large projects with many dependencies.
\begin{lstlisting}[numbers=left]

[escapeinside=\\\{\}]
\ltyp{ApiDocs}{.}\id{GenerateHtml}{(}
    {[} \id{projectInput} {]}{,}
    \lfun{output} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"output"}{)}{,}
    \lfun{collectionName} \ops{=} \str{"Project X"}{,}
    \lfun{template} \ops{=} \ltyp{Path}{.}\id{Combine}{(}\id{root}{,} \str{"templates"}{,} \str{"template.html"}{)}{,}
    \lfun{substitutions} \ops{=} {[}{]}{,}
    \lfun{libDirs} \ops{=} {[} \str{"ProjectX/bin/Debug/netstandard2.0"} {]}
{)}

\end{lstlisting}

\subsection*{Rebasing Links}



The \texttt{root} parameter is used for the base of page and image links in the generated documentation. By default, it is derived from the project's \texttt{<PackageProjectUrl>} property.


In some instances, you may wish to override the value for \texttt{root} (perhaps for local testing). To do this, you can use the command-line argument \texttt{--parameters root <base>}.


For example:
\begin{lstlisting}
dotnet fsdocs build --output public/docs --parameters root ../

\end{lstlisting}


\end{document}