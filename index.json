[{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\apidocs.html","title":"API Documentation generation\r\n","content":"(*** condition: prepare ***)\n#nowarn \"211\"\n#I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n#r \"FSharp.Formatting.Common.dll\"\n#r \"FSharp.Formatting.Markdown.dll\"\n#r \"FSharp.Formatting.CodeFormat.dll\"\n#r \"FSharp.Formatting.Literate.dll\"\n(*** condition: fsx ***)\n#if FSX\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // IPYNB\n\n(*** hide ***)\nlet root = \"C:\\\\\"\n\n(**\nAPI Documentation generation \n====================================\n\nThe [command-line tool `fsdocs`](commandline.html) can be used to generate documentation \nfor F# libraries with XML comments.  The documentation is normally built using `fsdocs build` and developed using `fsdocs watch`. For\nthe former the output will be placed in `output\\reference` by default.\n\n## Templates\n\nThe HTML is built by instantiating a template. The template used is the first of:\n\n* `docs/reference/_template.html` \n\n* `docs/_template.html`\n\n* The default template\n\nUsually the same template can be used as for [other content](content.html).\n\n## Classic XML Comments\n\nXML Comments may use [the normal F# and C# XML doc standards](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/).\n\nAn example of an XML documentation comment:\n*)\n/// <summary>\n/// Some actual comment\n/// <para>Another paragraph</para>\n/// </summary>\nmodule Foo2 = \n   let a = 42\n\n(**\n\n\n## Go to Source links\n\n'fsdocs' normally automatically adds GitHub links to each functions, values and class members for further reference.\n\nThis is normally done automatically based on the following settings:\n\n    <RepositoryUrl>https://github.com/...</RepositoryUrl>\n    <RepositoryBranch>...</RepositoryBranch>\n    <RepositoryType>git</RepositoryType>\n\nIf your source is not built from the same project where you are building documentation then\nyou may need these settings:\n\n    <FsDocsSourceRepository>...</FsDocsSourceRepository> -- the URL for the root of the source \n    <FsDocsSourceFolder>...</FsDocsSourceFolder>         -- the root soure folder at time of build\n\nIt is assumed that `sourceRepo` and `sourceFolder` have synchronized contents.\n\n## Markdown Comments\n\nYou can use Markdown instead of XML in `///` comments. If you do, you should set `<UsesMarkdownComments>` in\nyour F# project file.\n\n> Note: Markdown Comments are not supported in all F# IDE tooling.\n\n### Adding cross-type links to modules and types in the same assembly\n\nYou can automatically add cross-type links to the documentation pages of other modules and types in the same assembly.\nYou can do this in two different ways:\n\n* Add a [markdown inline link](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#links) were the link\ntitle is the name of the type you want to link.\n\n      /// this will generate a link to [Foo.Bar] documentation\n\n* Add a [Markdown inline code](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#code) (using\nback-ticks) where the code is the name of the type you want to link.\n\n      /// This will also generate a link to `Foo.Bar` documentation\n\nYou can use either the full name (including namespace and module) or the simple name of a type.\nIf more than one type is found with the same name the link will not be generated.\nIf a type with the given name is not found in the same assembly the link will not be generated.\n*)\n\n/// Contains two types [Bar] and [Foo.Baz]\nmodule Foo = \n    \n    /// Bar is just an `int` and belongs to module [Foo]\n    type Bar = int\n    \n    /// Baz contains a `Foo.Bar` as its `id`\n    type Baz = { id: Bar }\n\n    /// This function operates on `Baz` types.\n    let f (b:Baz) = \n        b.id * 42\n\n/// Referencing [Foo3] will not generate a link as there is no type with the name `Foo3`\nmodule Foo3 =\n    \n    /// This is not the same type as `Foo.Bar`\n    type Bar = double\n\n    /// Using the simple name for [Bar] will fail to create a link because the name is duplicated in \n    /// [Foo.Bar] and in [Foo3.Bar]. In this case, using the full name works.\n    let f2 b =\n         b * 50\n\n(**\n### Markdown Comments: Excluding APIs from the docs\n\nIf you want to exclude modules or functions from the API docs you can use the `[omit]` tag.\nIt needs to be set on a separate tripple-slashed line, but it could be either the first or the last:\n\n*)\n/// [omit]\n/// Some actual comment\nmodule Bar = \n   let a = 42\n(**\n\n\n## Building library documentation programmatically\n\nYou can build library documentation programatically. To do this, load the assembly and open necessary namespaces:\n*)\n\n#r \"FSharp.Formatting.ApiDocs.dll\"\nopen FSharp.Formatting.ApiDocs\nopen System.IO\n\n(**\nBuilding the library documentation is easy - you just need to call\n`ApiDocs.Generate` from your FAKE script or from F# Interactive.\nAssuming `root` is the root directory for your project, you can write:\n*)\n\nlet file = Path.Combine(root, \"bin/YourLibrary.dll\")\nlet input = ApiDocInput.FromFile(file) \nApiDocs.GenerateHtml\n    ( [ input ], \n      output=Path.Combine(root, \"output\"),\n      collectionName=\"YourLibrary\",\n      template=Path.Combine(root, \"templates\", \"template.html\"),\n      parameters=[])\n"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\codeformat.html","title":"Code formatting\r\n","content":"(*** condition: prepare ***)\n#nowarn \"211\"\n#I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n#r \"FSharp.Formatting.Common.dll\"\n#r \"FSharp.Formatting.Markdown.dll\"\n#r \"FSharp.Formatting.CodeFormat.dll\"\n#r \"FSharp.Formatting.Literate.dll\"\n(*** condition: fsx ***)\n#if FSX\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // IPYNB\n\n(**\nCode formatting\n==============================\n\nThis page demonstrates how to use `FSharp.Formatting.CodeFormat.dll` to tokenize \nF# source code, obtain information about the source code (mainly tooltips\nfrom the type-checker) and how to turn the code into a nicely formatted HTML.\n\nFirst, we need to load the assembly and open necessary namespaces:\n*)\n\nopen FSharp.Formatting.CodeFormat\nopen System.Reflection\n\n(**\n\nStarting a background agent\n---------------------------\n\nThe `FSharp.Formatting.CodeFormat` namespace contains `CodeFormat` type which is the\nentry point. The static method `CreateAgent` starts a background worker that\ncan be called to format snippets repeatedly:\n*)\n\nlet formattingAgent = CodeFormat.CreateAgent()\n\n(**\nIf you want to process multiple snippets, it is a good idea to keep the \nformatting agent around if possible. The agent needs to load the F# compiler\n(which needs to load various files itself) and so this takes a long time. As the above\nexample shows, you can specify which version of `FSharp.Compiler.dll` to use.\n\nProcessing F# source\n--------------------\n\nThe formatting agent provides a `ParseSource` method (together with an asynchronous\nversion for use from F# and also a version that returns a .NET `Task` for C#).\nTo call the method, we define a simple F# code as a string:\n*)\n\nlet source = \"\"\"\n    let hello () = \n      printfn \"Hello world\"\n  \"\"\"\nlet snippets, errors = formattingAgent.ParseSource(\"C:\\\\snippet.fsx\", source)\n\n(**\nWhen calling the method, you need to specify a file name and the actual content\nof the script file. The file does not have to physically exist. It is used by the\nF# compiler to resolve relative references (e.g. `#r`) and to automatically name\nthe module including all code in the file.\n\nYou can also specify additional parameters, such as `*.dll` references, by passing \na third argument with compiler options (e.g. `\"-r:Foo.dll -r:Bar.dll\"`). \n\nThis operation might take some time, so it is a good idea to use an asynchronous \nvariant of the method. It returns two arrays - the first contains F# snippets\nin the source code and the second contains any errors reported by the compiler.\nA single source file can include multiple snippets using the same formatting tags\nas those used on [fssnip.net](http://www.fssnip.net) as documented in the\n[about page](http://www.fssnip.net/pages/About).\n\n\nWorking with returned tokens\n----------------------------\n\nEach returned snippet is essentially just a collection of lines and each line \nconsists of a sequence of tokens. The following snippet prints basic information\nabout the tokens of our sample snippet:\n*)\n\n// Get the first snippet and obtain list of lines\nlet (Snippet(title, lines)) = snippets |> Seq.head\n\n// Iterate over all lines and all tokens on each line\nfor (Line(_, tokens)) in lines do\n  for token in tokens do\n    match token with\n    | TokenSpan.Token(kind, code, tip) -> \n        printf \"%s\" code\n        tip |> Option.iter (fun spans ->\n          printfn \"%A\" spans)          \n    | TokenSpan.Omitted _ \n    | TokenSpan.Output _ \n    | TokenSpan.Error _ -> ()\n  printfn \"\"\n\n(**\nThe `TokenSpan.Token` is the most important kind of token. It consists of a kind\n(identifier, keyword, etc.), the original F# code and tool tip information.\nThe tool tip is further formatted using a simple document format, but we simply \nprint the value using the F# pretty printing, so the result looks as follows:\n\n    let hello[Literal \"val hello : unit -> unit\"; ...] () = \n      printfn[Literal \"val printfn : TextWriterFormat<'T> -> 'T\"; ...] \"Hello world\"\n\nThe `Omitted` token is generated if you use the special `(*[omit:...]*)` command.\nThe `Output` token is generated if you use the `// [fsi:...]` command to format\noutput returned by F# interactive. The `Error` command wraps code that should be \nunderlined with a red squiggle if the code contains an error.\n\nGenerating HTML output\n----------------------\n\nFinally, the `CodeFormat` type also includes a method `FormatHtml` that can be used\nto generate nice HTML output from an F# snippet. This is used, for example, on \n[F# Snippets](http://www.fssnip.net). The following example shows how to call it:\n*)\n\nlet prefix = \"fst\" \nlet html = CodeFormat.FormatHtml(snippets, prefix)\n\n// Print all snippets, in case there is more of them\nfor snip in html.Snippets do\n  printfn \"%s\" snip.Content\n\n// Print HTML code that is generated for ToolTips\nprintfn \"%s\" html.ToolTip\n\n(**\nIf the input contains multiple snippets separated using the `//[snippet:...]` comment, e.g.:\n*)\n\n(**\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\">\n<span class=\"l\">1: </span>\n<span class=\"l\">2: </span>\n<span class=\"l\">3: </span>\n<span class=\"l\">4: </span>\n<span class=\"l\">5: </span>\n<span class=\"l\">6: </span>\n<span class=\"l\">7: </span>\n</pre>\n</td>\n<td class=\"snippet\"><pre class=\"fssnip\"><span class=\"c\">// [snippet: First sample]</span>\n<span class=\"i\">printf</span> <span class=\"s\">\"The answer is: %A\"</span> <span class=\"n\">42</span>\n<span class=\"c\">// [/snippet]</span>\n\n<span class=\"c\">// [snippet: Second sample]</span>\n<span class=\"i\">printf</span> <span class=\"s\">\"Hello world!\"</span>\n<span class=\"c\">// [/snippet]</span>\n</pre>\n</td>\n</tr>\n</table>\n*)\n\n(**\nthen the formatter returns multiple HTML blocks. However, the generated tool tips\nare shared by all snippets (to save space) and so they are returned separately.\n*)"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\commandline.html","title":"Command line tool\r\n","content":"# Command line tool\r\n\r\nTo use F# Formatting tools via the command line, you can use the `fsdocs` dotnet tool.\r\n\r\n    [lang=text]\r\n    dotnet tool install FSharp.Formatting.CommandTool\r\n    dotnet fsdocs [command] [options]\r\n\r\n## The build command\r\n\r\nThis command processes a `docs` directory and generates API docs for projects in the solution according to the\r\nrules of [API doc generation](apidocs.html). The input accepted is described in [content](content.html).\r\n\r\n    [lang=text]\r\n    fsdocs build\r\n\r\nThe command line options accepted are:\r\n\r\n| Command Line Option                 |  Description    |\r\n|:-----------------------|:-----------------------------------------|\r\n| `--input`     |   Input directory of content (default: `docs`) |\r\n| `--projects`     |   Project files to build API docs for outputs, defaults to all packable projects |\r\n| `--output`         |           Output Directory (default 'output' for 'build' and 'tmp/watch' for 'watch') |\r\n| `--noapidocs`       |           Disable generation of API docs |\r\n| `--eval`             |         Evaluate F# fragments in scripts |\r\n| `--saveimages`        |        Save images referenced in docs |\r\n| `--nolinenumbers`       |      Don't add line numbers, default is to add line number. |\r\n| `--parameters`            |    Additional substitution parameters for templates |\r\n| `--nonpublic`           |      The tool will also generate documentation for non-public members |\r\n| `--nodefaultcontent`      |    Do not copy default content styles, javascript or use default templates |\r\n| `--clean`                 |    Clean the output directory |\r\n| `--help`                  |    Display this help screen |\r\n| `--version`               |    Display version information |\r\n\r\nThe following command line options are also accepted but it is instead recommended you use\r\nsettings in your .fsproj project files:\r\n\r\n| Command Line Option                 |  Description    |\r\n|:-----------------------|:-----------------------------------------|\r\n| `--sourcefolder`       |       Source folder at time of component build (`<FsDocsSourceFolder>`) |\r\n| `--sourcerepo`         |       Source repository for github links (`<FsDocsSourceRepository>`) |\r\n| `--mdcomments`           |     Assume comments in F# code are markdown (`<UsesMarkdownComments>`) |\r\n\r\n## The watch command\r\n\r\nThis command does the same as `fsdocs build` but in \"watch\" mode, waiting for changes. Only the files in the input\r\ndirectory (e.g. `docs`) are watched.\r\n\r\n    [lang=text]\r\n    fsdocs watch\r\n\r\n Restarting may be necesssary on changes to project files. The same parameters are accepted, plus these:\r\n\r\n| Command Line Option                 |  Description    |\r\n|:-----------------------|:-----------------------------------------|\r\n| `--noserver`     |   Do not serve content when watching.  |\r\n| `--nolaunch`     |   Do not launch a browser window. |\r\n| `--open`     |   URL extension to launch http://localhost:<port>/%s. |\r\n| `--port`     |   Port to serve content for http://localhost serving. |\r\n\r\n\r\n\r\n## Searchable docs\r\n\r\nWhen using the command-line tool a Lunr search index is automatically generated in `index.json`.\r\n\r\nA search box is included in the default template.  To add a search box\r\nto your own `_template.html`, include `fsdocs-search.js`, which is added to the `content`\r\nby default.\r\n\r\n    [lang=text]\r\n    ...\r\n    <div id=\"header\">\r\n      <div class=\"searchbox\">\r\n        <label for=\"search-by\">\r\n          <i class=\"fas fa-search\"></i>\r\n        </label>\r\n        <input data-search-input=\"\" id=\"search-by\" type=\"search\" placeholder=\"Search...\" />\r\n        <span data-search-clear=\"\">\r\n          <i class=\"fas fa-times\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    ...\r\n\r\n"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\content.html","title":"Creating Content\r\n","content":"(*** condition: prepare ***)\n#nowarn \"211\"\n#I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n#r \"FSharp.Formatting.Common.dll\"\n#r \"FSharp.Formatting.Markdown.dll\"\n#r \"FSharp.Formatting.CodeFormat.dll\"\n#r \"FSharp.Formatting.Literate.dll\"\n(*** condition: fsx ***)\n#if FSX\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // IPYNB\n\n\n(**\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/fsprojects/FSharp.Formatting/gh-pages?filepath=literate.ipynb)\n\nCreating Content\n===================================\n\nThe [\"fsdocs\" tool](commandline.html) allows documentation for a site to be built\nfrom content in a `docs` directory. The expected structure for a `docs` directory is\n\n    [lang=text]\n    docs/**/*.md                  -- markdown with embedded code, converted to html and optionally tex/ipynb\n    docs/**/*.fsx                 -- fsx scripts converted to html and optionally tex/ipynb\n    docs/**/*                     -- other content, copied over\n    docs/**/_template.html        -- optional template, specifies the HTML template for this directory and its contents\n    docs/**/_template.tex         -- optionally indicates Latex files should be generated\n    docs/**/_template.ipynb       -- optionally indicates F# ipynb files should be generated\n    docs/**/_template.fsx         -- optionally indicates F# fsx files should be generated (even from markdown)\n    docs/reference/_template.html -- optionally specifies the default template for reference docs\n\nProcessing is by these two commands:\n\n    dotnet fsdocs build\n    dotnet fsdocs watch\n\nThe output goes in `output/` by default.  Processing is recursive, making this a form of static site generation.\n\n## Literate Scripts and Markdown\n\nThe input directory may contain [literate scripts and markdown](literate.html).\n\n## Other Content\n\nContent that is not `*.fsx` or `*.md` is copied across.\n\n## Default Styling Content\n\nBy default additional content such as `fsdocs-search.js`, `fsdocs-tips.js` and `fsdocs-styles.css` are included in the\nthe `content` directory of the output.  This can be suppressed with `--nodefaultcontent` or by having your own\ncopy of this content in your `content` directory.\n\n## Ignored Content\n\nAny file or directory beginning with `.` is ignored.\n\n## HTML Templates\n\nTemplate files are named `_template.html` and should contain `{{fsdocs-content}}`,  `{{fsdocs-tooltips}}`\nand other placeholders.\nIf a file `_template.html` exists then is used as the template for HTML generation for that directory and all sub-content.\nOtherwise the default template is used.\n\nThe following substitutions determine the primary (non-styling) content of your site.\nFor example `{{fsdocs-content}}` is replaced with the generated content.\n\nSee [Styling](styling.html) for information about template parameters and styling beyond the default template.\n\n|  Substitution name                  | Generated content |  \n|:------------------------------------|:--------------------------------------------------------------|\n| `root`                        | `<RepositoryUrl>` else `/`                                    |  \n| `fsdocs-content`              | Main page content                                             |   \n| `fsdocs-list-of-namespaces`   | HTML `<li>` list of namespaces with links                     |  \n| `fsdocs-list-of-documents`    | HTML `<li>` list of documents with  titles and links          |  \n| `fsdocs-page-title`           | First h1 heading in literate file. Generated for API docs     | \n| `fsdocs-source`               | Original script source                                        | \n| `fsdocs-tooltips`             | Generated hidden div elements for tooltips                    | \n\n\nThe following substitutions are extracted from your project files and may or may not be used by the default\ntemplate:\n\n|  Substitution name                  | Value   | \n|:------------------------------------|:--------------------------------------------------------------| \n| `fsdocs-copyright`            | `<Copyright>`                                                 |  \n| `fsdocs-package-project-url`  | `<PackageProjectUrl>`                                         | \n| `fsdocs-package-license-expression`  | `<PackageLicenseExpression>`                           |\n| `fsdocs-package-tags`         | `<PackageTags>`                                               |  \n| `fsdocs-package-version`      | `<Version>`                                                   |  \n\n## Generating LaTeX output\n\nFor Latex, the the `_template.tex` file is either empty of contains `{content}` as the key where the body\nof the document is placed. \n\nTo generate .tex output for each script and markdown file, add a `_template.tex`.\nIt may contain `{{fsdocs-content}}`. \n\n## Generating iPython Notebook output\n\nTo generate .ipynb output for each script and markdown file, add a `_template.ipynb`, usually empty.\n\nTo add a `mybinder` badge to your generated notebook, ensure you have a `Dockerfile` and `NuGet.config`\nin your `docs` directory and use text like this:\n\n    [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/fsprojects/FSharp.Formatting/gh-pages?filepath=literate.ipynb)\n    \n## Generating Script outputs\n\nTo generate .fsx output for each script and markdown file, add a `_template.fsx`, usually empty.\nIt may contain `{{fsdocs-content}}`.\n\n*)"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\evaluation.html","title":"Embedding literate script output\r\n","content":"(*** condition: prepare ***)\n#nowarn \"211\"\n#I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n#r \"FSharp.Formatting.Common.dll\"\n#r \"FSharp.Formatting.Markdown.dll\"\n#r \"FSharp.Formatting.CodeFormat.dll\"\n#r \"FSharp.Formatting.Literate.dll\"\n(*** condition: fsx ***)\n#if FSX\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // IPYNB\n\n(**\n# Embedding literate script output\n\n\nFor literate F# scripts, you may embed the result of running the script as part of the literate output.\nThis is a feature of the functions discussed in [literate programming](literate.html) and\nit is implemented using the [F# Compiler service](http://fsharp.github.io/FSharp.Compiler.Service/).\n\n## Including Console Output\n\nTo include the Console output use ``include-output``:\n\n    let test = 40 + 2\n\n    printf \"A result is: %d\" test\n    (*** include-output ***)\n\nThe script defines a variable `test` and then prints it. The console output is included\nin the output.\n\nTo include the a formatted value use ``include-it``:\n\n    [ 0 .. 99 ]\n\n    (*** include-it ***)\n\n\nTo include the meta output of F# Interactive processing such as type signatures use `(*** include-fsi-output ***)`:\n\n    let test = 40 + 3\n\n    (*** include-fsi-output ***)\n\nTo include both console otuput and F# Interactive output blended use `(*** include-fsi-merged-output ***)`.\n\n    let test = 40 + 4\n    (*** include-fsi-merged-output ***)\n\nYou can use the same commands with a named snippet:\n\n    (*** include-it: test ***)\n    (*** include-fsi-output: test ***)\n    (*** include-output: test ***)\n\nYou can use the `include-value` command to format a specific value:\n\n    let value1 = [ 0 .. 50 ]\n    let value2 = [ 51 .. 100 ]\n    (*** include-value: value1 ***)\n\n## Using AddPrinter and AddHtmlPrinter\n\nYou can use `fsi.AddPrinter`, `fsi.AddPrintTransformer` and `fsi.AddHtmlPrinter` to extend the formatting of objects.\n\n## Emitting Raw Text\n\nTo emit raw text in F# literate scripts use the following:\n\n\t(**\n\t\t(*** raw ***)\n\t\tSome raw text.\n\t*)\n\nwhich would emit\n\n<pre>\nSome raw text.\n</pre>\n\ndirectly into the document.\n\nF# Formatting as a Library:  Specifying the Evaluator and Formatting \n---------------------------------------\n\nIf using F# Formatting as a library the embedding of F# output requires specifying an additional parameter to the \nparsing functions discussed in [literate programming documentation](literate.html).\nAssuming you have all the references in place, you can now create an instance of\n`FsiEvaluator` that represents a wrapper for F# interactive and pass it to all the\nfunctions that parse script files or process script files:\n\n*)\nopen FSharp.Formatting.Literate\nopen FSharp.Formatting.Literate.Evaluation\nopen FSharp.Formatting.Markdown\n\n// Sample literate content\nlet content = \"\"\"\nlet a = 10\n(*** include-value:a ***)\"\"\"\n\n// Create evaluator and parse script\nlet fsi = FsiEvaluator()\nlet doc = Literate.ParseScriptString(content, fsiEvaluator = fsi)\nLiterate.ToHtml(doc)\n(**\nWhen the `fsiEvaluator` parameter is specified, the script is evaluated and so you\ncan use additional commands such as `include-value`. When the evaluator is *not* specified,\nit is not created automatically and so the functionality is not available (this way,\nyou won't accidentally run unexpected code!)\n\nIf you specify the `fsiEvaluator` parameter, but don't want a specific snippet to be evaluated\n(because it might throw an exception, for example), you can use the `(*** do-not-eval ***)` \ncommand.\n\nThe constructor of `FsiEvaluator` takes command line parameters for `fsi.exe` that can\nbe used to specify, for example, defined symbols and other attributes for F# Interactive.\n\nYou can also subscribe to the `EvaluationFailed` event which is fired whenever the evaluation\nof an expression fails. You can use that to do tests that verify that all off the code in your\ndocumentation executes without errors.\n\nF# Formatting as a Library: Custom formatting functions\n---------------------------\n\nAs mentioned earlier, values are formatted using a simple `\"%A\"` formatter by default.\nHowever, you can specify a formatting function that provides a nicer formatting for values\nof certain types. For example, let's say that we would want to format F# lists such as\n`[1; 2; 3]` as HTML ordered lists `<ol>`. \n\nThis can be done by calling `RegisterTransformation` on the `FsiEvaluator` instance:\n\n*)\n// Create evaluator & register simple formatter for lists\nlet fsiOl = FsiEvaluator()\nfsiOl.RegisterTransformation(fun (o, ty, _executionCount) ->\n  // If the type of value is an F# list, format it nicely\n  if ty.IsGenericType && ty.GetGenericTypeDefinition() = typedefof<list<_>> then\n    let items = \n      // Get items as objects and create paragraph for each item\n      [ for it in Seq.cast<obj> (unbox o) -> \n          [ Paragraph([Literal(it.ToString(), None)], None) ] ]\n    // Return option value (success) with ordered list\n    Some [ ListBlock(MarkdownListKind.Ordered, items, None) ]\n  else None)\n(**\n\nThe function is called with two arguments - `o` is the value to be formatted and `ty`\nis the static type of the value (as inferred by the F# compiler). The sample checks\nthat the type of the value is a list (containing values of any type) and then it \ncasts all values in the list to `obj` (for simplicity). Then we generate Markdown\nblocks representing an ordered list. This means that the code will work for both\nLaTeX and HTML formatting - but if you only need one, you can simply produce HTML and\nembed it in `InlineBlock`.\n\nTo use the new `FsiEvaluator`, we can use the same style as earlier. This time, we format\na simple list containing strings:\n*)\nlet listy = \"\"\"\n### Formatting demo\nlet test = [\"one\";\"two\";\"three\"]\n(*** include-value:test ***)\"\"\"\n\nlet docOl = Literate.ParseScriptString(listy, fsiEvaluator = fsiOl)\nLiterate.ToHtml(docOl)\n(**\nThe resulting HTML formatting of the document contains the snippet that defines `test`,\nfollowed by a nicely formatted ordered list:\n\n<blockquote>\n<h3>Formatting demo</h3>\n<table class=\"pre\"><tr><td class=\"lines\"><pre class=\"fssnip\">\n<span class=\"l\">1: </span>\n</pre>\n</td>\n<td class=\"snippet\"><pre class=\"fssnip\">\n<span class=\"k\">let</span> <spanclass=\"i\">test</span> <span class=\"o\">=</span> [<span class=\"s\">&quot;</span><span class=\"s\">one</span><span class=\"s\">&quot;</span>;<span class=\"s\">&quot;</span><span class=\"s\">two</span><span class=\"s\">&quot;</span>;<span class=\"s\">&quot;</span><span class=\"s\">three</span><span class=\"s\">&quot;</span>]</pre>\n</td>\n</tr>\n</table>\n<ol>\n<li><p>one</p></li>\n<li><p>two</p></li>\n<li><p>three</p></li>\n</ol>\n</blockquote>\n\n*)"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\index.html","title":"F# Formatting: Documentation Tools for F# Code\r\n","content":"[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/fsprojects/FSharp.Formatting/gh-pages?filepath=index.ipynb)\r\n\r\n# F# Formatting: Documentation Tools for F# Code\r\n\r\nFSharp.Formatting is a set of libraries and tools for processing F# script files, markdown and for\r\ngenerating API documentation. F# Formatting package is used by the this project and many other repositories.\r\n\r\nTo use the tool, install and use the [fsdocs](commandline.html) tool in a typical F# project with\r\nF# project files plus markdown and script content in the `docs` directory:\r\n\r\n    dotnet tool install FSharp.Formatting.CommandTool\r\n    dotnet fsdocs build \r\n    dotnet fsdocs watch\r\n\r\nTo use the tool, explore the following topics:\r\n\r\n- [Authoring Content](content.html) - explains the content expected in the `docs` directory for the `fsdocs` tool.\r\n\r\n- [Using the Command line tool](commandline.html) - explains how to use the `fsdocs` tool.\r\n\r\n- [Generating API documentation](apidocs.html) - how to generate HTML documentation\r\n  from \"XML comments\" in your .NET libraries. The tool handles comments written in\r\n  Markdown too.\r\n\r\n- [Styling](styling.html) - explains some options for styling the output of `fsdocs`.\r\n\r\n- [Using literate programming](literate.html) - explains how to generate documentation\r\n  for your projects or to write nicely formatted F# blog posts. \r\n\r\n- [Embedding F# outputs in literate programming](evaluation.html) - provides more details on literate programming and\r\n  explains how to embed results of a literate script file in the generated output. This way,\r\n  you can easily format the results of running your code!\r\n\r\n## Using FSharp.Formatting as a library\r\n\r\nF# Formatting is also [available on NuGet](https://nuget.org/packages/FSharp.Formatting) as a set of libraries. \r\n\r\n- [Markdown parser](markdown.html) - explains the F# Markdown\r\n  processor that is available in this library with some basic examples of\r\n  document processing.\r\n\r\n- [F# code formatting](codeformat.html) - more details about the F# code\r\n  formatter and how to use it to obtain information about F# source files.\r\n\r\n## More information\r\n\r\nThe documentation for this library is generated automatically using the tools\r\nbuilt here. If you spot a typo, please submit a pull request! The source Markdown and F# script files are\r\navailable in the [docs folder on GitHub](https://github.com/fsprojects/FSharp.Formatting/tree/master/docs).\r\n\r\nThe project is hosted on [GitHub](https://github.com/fsprojects/FSharp.Formatting) where you can \r\n[report issues](https://github.com/fsprojects/FSharp.Formatting/issues), fork the project and submit pull requests.\r\nSee the  [License file](https://github.com/fsprojects/FSharp.Formatting/blob/master/LICENSE.md) in the GitHub repository."},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\literate.html","title":"Literate Scripts and Markdown\r\n","content":"(*** condition: prepare ***)\n#nowarn \"211\"\n#I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n#r \"FSharp.Formatting.Common.dll\"\n#r \"FSharp.Formatting.Markdown.dll\"\n#r \"FSharp.Formatting.CodeFormat.dll\"\n#r \"FSharp.Formatting.Literate.dll\"\n(*** condition: fsx ***)\n#if FSX\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // IPYNB\n\n\n(**\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/fsprojects/FSharp.Formatting/gh-pages?filepath=literate.ipynb)\n\nLiterate Scripts and Markdown\n===================================\n\nThe following example shows most of the features that can be used in a literate\nF# script file with `.fsx` extension. Most of the features should be quite self-explanatory:\n\n    (**\n    # First-level heading\n    Some more documentation using `Markdown`.\n    *)\n    \n    let helloWorld() = printfn \"Hello world!\"\n\n    (** \n    ## Second-level heading\n    With some more documentation\n    *)\n    \n    let numbers = [ 0 .. 99 ]\n    (*** include-value: numbers ***)\n\n    List.sum numbers\n    (*** include-it ***)\n\nThe F# script files is processed as follows:\n\n- A multi-line comment starting with `(**` and ending with `*)` is \n  turned into text and is processed using the F# Markdown processor \n  (which supports standard Markdown commands).\n\n- A single-line comment starting with `(***` and ending with `***)` \n  is treated as a special command. The command can consist of \n  `key`, `key: value` or `key=value` pairs.\n\n|  Literate Command     | Description               |\n|:-----------------------|:----------------------------|\n|   `(** ... *)`       | Markdown  |\n|   `(*** condition: prepare ***)`       | Utilise a code snippet when analyzing for tooltips or executing for outputs |\n|   `(*** condition: ipynb ***)`       | Include a code snippet when making a .ipynb notebook  |\n|   `(*** condition: tex ***)`       | Include a code snippet when making a .tex output   |\n|   `(*** condition: html ***)`       | Include a code snippet when making HTML output   |\n|   `(*** hide ***)`       | Hide the subsequent snippet  |\n|   `(*** include-output ***)`       | The output of the preceeding snippet   |\n|   `(*** include-fsi-output ***)`       | The F# Interactive output of the preceeding snippet   |\n|   `(*** include-fsi-merged-output ***)`       | The merge of console output and F# Interactive output of the preceeding snippet   |\n|   `(*** include-it ***)`       | The formatted result of the preceeding snippet |\n|   `(*** include-value: value-name ***)`       | The formatted value  |\n|   `(*** raw ***)`       | The subsequent code is treated as raw text |\n\n### Named snippets\n\nThe command `define` defines a named snippet (such as `final-sample`) and removes the command together with \nthe following F# code block from the main document. The snippet can then\nbe referred to using these variations. This makes it\npossible to write documents without the ordering requirements of the\nF# language.\n\n|  Literate Command     | Description               |\n|:-----------------------|:----------------------------|\n|   `(*** define: snippet-name ***)`       | Define a named snippet  |\n|   `(*** include-output: snippet-name ***)`       | The output of the named snippet  |\n|   `(*** include-fsi-output: snippet-name ***)`       | The F# Interactive output of the named snippet  |\n|   `(*** include-fsi-merged-output: snippet-name ***)`       | The merge of console output and F# Interactive output of the named snippet  |\n|   `(*** include-it: snippet-name ***)`       | The formatted result of the named snippet  |\n|   `(*** include: snippet-name ***)`       | Include the code of the named snippet |\n\n#### Hiding code snippets\n\nThe command `hide` specifies that the following F# code block (until the next comment or command) should be \nomitted from the output.\n\n#### Evaluating and formatting results\n\nThe commands to evaluate and format results are explained in [evaluation](evaluation.html).\nYou must build your documentation with evaluation turned on using `--eval`.\n\n### Literate Markdown Documents\n\nFor files with `.md` extension, the entire file is a Markdown document, which may\ncontain F# code snippets (but also other code snippets). As usual, snippets are\nindented with four spaces. In addition, the snippets can be annotated with special\ncommands. Some of them are demonstrated in the following example: \n\n    [lang=text]\n    # First-level heading\n\n        [hide]\n        let print s = printfn \"%s\" s\n\n    Some more documentation using `Markdown`.\n\n        [module=Hello]\n        let helloWorld() = print \"Hello world!\"\n\n    ## Second-level heading\n    With some more documentation\n\n        [lang=csharp]\n        Console.WriteLine(\"Hello world!\");\n\nWhen processing the document, all F# snippets are copied to a separate file that\nis type-checked using the F# compiler (to obtain colours and tool tips).\nThe commands are written on the first line of the named snippet, wrapped in `[...]`:\n\n - The `hide` command specifies that the F# snippet should not be included in the\n   final document. This can be used to include code that is needed to type-check\n   the code, but is not visible to the reader.\n\n - The `module=Foo` command can be used to specify F# `module` where the snippet\n   is placed. Use this command if you need multiple versions of the same snippet\n   or if you need to separate code from different snippets.\n\n - The `lang=foo` command specifies the language of the named snippet. If the language\n   is other than `fsharp`, the snippet is copied to the output as `<pre>` HTML\n   tag without any processing.\n\n*)\n\n(**\n### LaTeX in Literate Scripts and Markdown Documents\n\nLiterate Scripts may contain LaTeX sections in Markdown using these forms:\n\n1. Single line latex starting with `$$`.\n\n2. A block delimited by `\\begin{equation}...\\end{equation}` or `\\begin{align}...\\end{align}`. \n\n3. An indented paragraph starting with `$$$`.  This is F#-literate-specific and corresponds to\n   `\\begin{equation}...\\end{equation}`.\n\nFor example\n\n    [lang=text]\n    $$\\frac{x}{y}$$\n\n    \\begin{equation}\n       \\frac{d}{dx} \\left. \\left( x \\left( \\left. \\frac{d}{dy} x y \\; \\right|_{y=3} \\right) \\right) \\right|_{x=2}\n    \\end{equation}\n\nBecomes\n\n$$\\frac{x}{y}$$\n\n\\begin{equation}\n   \\frac{d}{dx} \\left. \\left( x \\left( \\left. \\frac{d}{dy} x y \\; \\right|_{y=3} \\right) \\right) \\right|_{x=2}\n\\end{equation}\n\nThe LaTeX will also be used in HTML and iPython notebook outputs.\n\n### Making literate scripts work for different outputs\n\nLiterate scripts and markdown can by turned into LaTex, Python Notebooks and F# scripts.\n\nA header may be needed to get the code to load, a typical example is this:\n\n    (*** condition: prepare ***)\n    #nowarn \"211\"\n    #I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n    #r \"FSharp.Formatting.Common.dll\"\n    #r \"FSharp.Formatting.Markdown.dll\"\n    #r \"FSharp.Formatting.CodeFormat.dll\"\n    #r \"FSharp.Formatting.Literate.dll\"\n    (*** condition: fsx ***)\n    #if FSX\n    #r \"nuget: FSharp.Formatting,{{package-version}}\"\n    #endif // FSX\n    (*** condition: ipynb ***)\n    #if IPYNB\n    #r \"nuget: FSharp.Formatting,{{package-version}}\"\n    #endif // IPYNB\n\n### Processing literate files programatically\n\nTo process file Use the two static methods to turn single documents into HTML\nas follows:\n*)\nopen System.IO\nopen FSharp.Formatting.Literate\n\nlet source = __SOURCE_DIRECTORY__\nlet template = Path.Combine(source, \"template.html\")\n\nlet script = Path.Combine(source, \"../docs/script.fsx\")\nLiterate.ConvertScriptFile(script, template)\n\nlet doc = Path.Combine(source, \"../docs/document.md\")\nLiterate.ConvertMarkdownFile(doc, template)\n\n(**\n\nThe following sample also uses optional parameter `parameters` to specify additional\nkeywords that will be replaced in the template file (this matches the `template-project.html`\nfile which is included as a sample in the package):\n*)\n\n// Load the template & specify project information\nlet projTemplate = source + \"template-project.html\"\nlet projInfo =\n  [ \"fsdocs-authors\", \"Tomas Petricek\"\n    \"fsdocs-source-link\", \"https://github.com/fsprojects/FSharp.Formatting\"\n    \"fsdocs-collection-name\", \"F# Formatting\" ]\n\n(**\n\nThe methods used above (`ConvertScriptFile`, `ConvertMarkdownFile`) \nproduce HTML output by default, but they can be also used to produce LaTeX output. This is done\nby setting the output kind. The following\nexample shows how to call the methods to generate LaTeX documents:\n*)\nlet templateTex = Path.Combine(source, \"template.tex\")\n\nlet scriptTex = Path.Combine(source, \"../docs/script.fsx\")\nLiterate.ConvertScriptFile(scriptTex, templateTex, outputKind=OutputKind.Latex)\n\nlet docTex = Path.Combine(source, \"../docs/document.md\")\nLiterate.ConvertMarkdownFile(docTex, templateTex, outputKind=OutputKind.Latex)\n\n(**\n\nThe methods used above (`ConvertScriptFile`, `ConvertMarkdownFile`) \ncan also produce iPython Notebook output. This is done\nby setting the named parameter `format` to `OutputKind.Pynb`:\n*)\n\n// Process script file, Markdown document and a directory\nlet scriptPynb = Path.Combine(source, \"../docs/script.fsx\")\nLiterate.ConvertScriptFile(scriptPynb, outputKind=OutputKind.Pynb)\n\nlet docPynb = Path.Combine(source, \"../docs/document.md\")\nLiterate.ConvertMarkdownFile(docPynb, outputKind=OutputKind.Pynb)\n\n(**\n\nAll of the three methods discussed in the previous two sections take a number of optional\nparameters that can be used to tweak how the formatting works or even to specify a different\nversion of the F# compiler:\n\n - `prefix` - a string that is added to all automatically generated `id` attributes\n   in the generated HTML document (to avoid collisions with other HTML elements)\n - `fscoptions` - this can be used to pass any additional command line \n   parameters to the F# compiler (you can use any standard parameters of `fsc.exe`)\n - `lineNumbers` - if `true` then the generated F# snippets include line numbers.\n - `references` - if `true` then the script automatically adds a \"References\" \n   section with all indirect links that are defined and used in the document.\n - `parameters` - a list of key-value pairs containing additional parameters\n   that should be replaced in the tempalte HTML file.\n - `errorHandler` - a function that is used to report errors from the F# compiler \n   (if not specified, errors are printed to the standard output)\n - `generateAnchors` - when `true`, the generated HTML will automatically include\n   anchors for all headings (and so you can click on headings to get a link\n   to a section). The default value is `false`.\n - `customizeDocument` - Allows you to customize the document before writing it \n   to the output file. This gives you the opportunity to use your own\n   code formatting code, for example to support syntax highlighting for another language. \n\n*)"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\markdown.html","title":"Markdown parser\r\n","content":"(*** condition: prepare ***)\n#I \"../src/FSharp.Formatting/bin/Release/netstandard2.0\"\n#r \"FSharp.Formatting.Common.dll\"\n#r \"FSharp.Formatting.Markdown.dll\"\n(*** condition: fsx ***)\n#if FSX\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // FSX\n(*** condition: ipynb ***)\n#if IPYNB\n#r \"nuget: FSharp.Formatting,{{package-version}}\"\n#endif // IPYNB\n\n\n(**\n[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/fsprojects/FSharp.Formatting/gh-pages?filepath=markdown.ipynb)\n\nMarkdown parser\n==============================\n\nThis page demonstrates how to use `FSharp.Formatting.Markdown.dll` to parse a Markdown\ndocument, process the obtained document representation and\nhow to turn the code into a nicely formatted HTML.\n\nFirst, we need to load the assembly and open necessary namespaces:\n*)\n\nopen FSharp.Formatting.Markdown\nopen FSharp.Formatting.Common\n\n\n(**\nParsing documents\n-----------------\n\nThe F# Markdown parser recognizes the standard [Markdown syntax](http://daringfireball.net/projects/markdown/)\nand it is not the aim of this tutorial to fully document it. \nThe following snippet creates a simple string containing a document\nwith several elements and then parses it using the `Markdown.Parse` method:\n*)\n\nlet document = \"\"\"\n# F# Hello world\nHello world in [F#](http://fsharp.net) looks like this:\n\n    printfn \"Hello world!\"\n\nFor more see [fsharp.org][fsorg].\n\n  [fsorg]: http://fsharp.org \"The F# organization.\" \"\"\"\n\nlet parsed = Markdown.Parse(document)\n\n(**\nThe sample document consists of a first-level heading (written using \none of the two alternative styles) followed by a paragraph with a \n_direct_ link, code snippet and one more paragraph that includes an \n_indirect_ link. The URLs of indirect links are defined by a separate\nblock as demonstrated on the last line (and they can then be easily used repeatedly\nfrom multiple places in the document).\n\nWorking with parsed documents\n-----------------------------\n\nThe F# Markdown processor does not turn the document directly into HTML.\nInstead, it builds a nice F# data structure that we can use to analyze, \ntransform and process the document. First of all the `DefinedLinks` property\nreturns all indirect link definitions:\n*)\n\nparsed.DefinedLinks\n// [fsi:val it : IDictionary<string,(string * string option)> =]\n// [fsi:  dict [(\"fsorg\", (\"http://fsharp.org\", Some \"The F# organization.\"))]]\n\n(**\nThe document content can be accessed using the `Paragraphs` property that returns\na sequence of paragraphs or other first-level elements (headings, quotes, code snippets, etc.).\nThe following snippet prints the heading of the document:\n*)\n\n// Iterate over all the paragraph elements\nfor par in parsed.Paragraphs do\n  match par with\n  | Heading(size=1; body=[Literal(text=text)]) -> \n      // Recognize heading that has a simple content\n      // containing just a literal (no other formatting)\n      printfn \"%s\" text\n  | _ -> ()\n\n(**\nYou can find more detailed information about the document structure and how to process it\nin the book [F# Deep Dives](http://manning.com/petricek2/).\n\nProcessing the document recursively\n-----------------------------------\n\nThe library provides active patterns that can be used to easily process the Markdown \ndocument recursively. The example in this section shows how to extract all links from the\ndocument. To do that, we need to write two recursive functions. One that will process\nall paragraph-style elements and one that will process all inline formattings (inside\nparagraphs, headings etc.).\n\nTo avoid pattern matching on every single kind of span and every single kind of \nparagraph, we can use active patterns from the `MarkdownPatterns` module. These can be use\nto recognize any paragraph or span that can contain child elements:\n\n*)\n\n/// Returns all links in a specified span node\nlet rec collectSpanLinks span = seq {\n  match span with\n  | DirectLink(link=url) -> yield url\n  | IndirectLink(key=key) -> yield fst (parsed.DefinedLinks.[key])\n  | MarkdownPatterns.SpanLeaf _ -> ()\n  | MarkdownPatterns.SpanNode(_, spans) ->\n      for s in spans do yield! collectSpanLinks s }\n      \n/// Returns all links in the specified paragraph node\nlet rec collectParLinks par = seq {\n  match par with\n  | MarkdownPatterns.ParagraphLeaf _ -> ()\n  | MarkdownPatterns.ParagraphNested(_, pars) -> \n      for ps in pars do \n        for p in ps do yield! collectParLinks p \n  | MarkdownPatterns.ParagraphSpans(_, spans) ->\n      for s in spans do yield! collectSpanLinks s }\n\n/// Collect links in the entire document\nSeq.collect collectParLinks parsed.Paragraphs\n// [fsi:val it : seq<string> =]\n// [fsi:  seq [\"http://fsharp.net\"; \"http://fsharp.org\"]]\n\n(**\nThe `collectSpanLinks` function works on individual span elements that contain inline\nformatting (emphasis, strong) and also links. The `DirectLink` node represents an inline\nlink like the one pointing to <http://fsharp.net> while `IndirectLink` represents a\nlink that uses one of the link definitions. The function simply returns the URL associated\nwith the link.\n\nSome span nodes (like emphasis) can contain other formatting, so we need to recursively\nprocess children. This is done by matching against `MarkdownPatterns.SpanNodes` which is an active\npattern that recognizes any node with children. The library also provides a _function_\nnamed `MarkdownPatterns.SpanNode` that can be used to reconstruct the same node (when you want\nto transform document). This is similar to how the `ExprShape` module for working with \nF# quotations works.\n\nThe function `collectParLinks` processes paragraphs - a paragraph cannot directly be a \nlink so we just need to process all spans. This time, there are three options. \n`ParagraphLeaf` represents a case where the paragraph does not contain any spans\n(a code block or, for example, a `<hr>` line); the `ParagraphNested` case is used for paragraphs\nthat contain other paragraphs (quotation) and `ParagraphSpans` is used for all other\nparagraphs that contain normal text - here we call `collectSpanLinks` on all nested spans.\n\nGenerating HTML output\n----------------------\n\nFinally, the `Markdown` type also includes a method `ToHtml` that can be used\nto generate an HTML document from the Markdown input. The following example shows how to call it:\n*)\nlet html = Markdown.ToHtml(parsed)\n\n(**\nIn addition, you can also use `Markdown.TransformHtml` to directly turn an input document\nin the Markdown format into an HTML document (without the intermediate step).\n*)"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\styling.html","title":"Styling\r\n","content":"# Styling \r\n\r\nBy default `fsdocs` uses the following (which are the settings used to build this site):\r\n\r\n* the default template in [docs/_template.html](https://github.com/fsprojects/FSharp.Formatting/blob/master/docs/_template.html)\r\n\r\n* the default styles in [docs/content/fsdocs-default.css](https://github.com/fsprojects/FSharp.Formatting/blob/master/docs/content/fsdocs-default.css).\r\n\r\n* no custom styles in [docs/content/fsdocs-custom.css](https://github.com/fsprojects/FSharp.Formatting/blob/master/docs/content/fsdocs-default.css).\r\n\r\n* no styling parameters for the default template (see below)\r\n\r\nFor your project, you don't need any of these files. However you can add them if you wish, though if\r\nyou adjsut them there is no guarantee that your template will continue to work with future versions of F# Formatting.\r\n\r\n## Customizing via Styling Parameters\r\n\r\nThe following [content parameters](content.html) are particularly related to visual styling:\r\n\r\n|  Substitution name                  | Value (if not overriden by --parameters)                      | \r\n|:------------------------------------|:--------------------------------------------------------------|\r\n| `fsdocs-authors`              | `<Authors>`                                                   |  \r\n| `fsdocs-collection-name`      | Name of .sln, single .fsproj or containing directory          |  \r\n| `fsdocs-collection-name-link` | `<FsDocsCollectionNameLink>`        |  \r\n| `fsdocs-license-link`         | `<FsDocsLicenseLink>`  | \r\n| `fsdocs-logo-src`             | `<FsDocsLogoSource>` |  \r\n| `fsdocs-logo-link`            | `<FsDocsLogoLink>`   |                \r\n| `fsdocs-navbar-position`      | `<FsDocsNavbarPosition>` (`fixed-left` or `fixed-right`)     |  \r\n| `fsdocs-release-notes-link`   | `<FsDocsReleaseNotesLink>` else `<PackageProjectUrl>/blob/master/RELEASE_NOTES.md`  | \r\n| `fsdocs-repository-link`      | `<RepositoryUrl>`                                             | \r\n| `fsdocs-theme`                | `<FsDocsTheme>`, must currently be `default`    | \r\n\n\r\nAs an example, here is [a page with `fsdocs-navbar-position` set to `fixed-left`](templates/leftside/styling.html).\r\n\r\n## Customizing via CSS\r\n\r\nYou can start styling by creating a file `docs/fsdocs-custom.css` and adding entries to it.  It is loaded by\r\nthe standard template.  The CSS classes of generated content are:\n\n|  CSS class   | Corresponding Content|  \r\n|:------------------------------------|:--------------------------------------------------------------|\r\n| `.fsdocs-tip`              |   generated tooltips                                                  |  \r\n| `.fsdocs-member-list `      |  generated member lists  |\r\n| `.fsdocs-member-name `      |  generated member names |\r\n| `.fsdocs-member-tooltip `      |  generated tooltips for members |\r\n| `.fsdocs-xmldoc `      |  generated xmldoc sections  |\r\n| `.fsdocs-entity-list `      |  generated entity lists |\r\n| `.fsdocs-member-list `      |  generated member lists |\r\n\nSome generated elements are given specific HTML ids:\n\n|  HTML Element Id    | Content|  \r\n|:------------------------------------|:--------------------------------------------------------------|\r\n| `#fsdocs-content`              |    The generated content |  \r\n| `#fsdocs-searchbox `      |   The search box |\r\n| `#fsdocs-logo `      |  The logo |\r\n| `#fsdocs-menu `      |  The navigation-bar |\r\n\nIf you write a new theme by CSS styling please contribute it back to FSharp.Formatting.\n\r\n## Customizing via a new template\r\n\r\nYou can do advanced styling by creating a new template.  Add a file `docs/_template.html`, likely starting\r\nwith the existing default template.\r\n\r\n> NOTE: There is no guarantee that your template will continue to work with future versions of F# Formatting.\r\n> If you do develop a good template please consider contributing it back to F# Formatting.\r\n\r\n\r\n"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\upgrade.html","title":"Upgrading to fsdocs\r\n","content":"\r\n\r\n# Upgrading to fsdocs\r\n\r\nHere are the typical steps to upgrade a repo based on `ProjectScaffold` to use `fsdocs`\r\n\r\n1. Run\r\n\r\n       [lang=text]\r\n       dotnet new tool\r\n       dotnet tool install FSharp.Formatting.CommandTool\r\n\r\n2. Delete all of `docs\\tools` particularly `docs\\tool\\generate.fsx`.  Keep a copy of any templates for reference as you'll have to copy some bits across to the new template.\r\n\r\n3. Put your docs directory so it refelcts the final shape of the site. For example move the content of `docs\\input\\*` and `docs\\files\\*` directly to `docs\\*`\r\n\r\n4. Create `docs\\_template.html`, starting with [this file](https://github.com/fsprojects/FSharp.Formatting/blob/master/misc/templates/_template.html) and \r\n   copying across any snippets from old templates.\r\n\r\n5. Run\r\n\r\n       [lang=text]\r\n       dotnet fsdocs watch\r\n\r\n   and edit and test your docs.\r\n\r\n6. If using FAKE adjust `build.fsx` e.g.\r\n\r\n       [lang=text]\r\n       Target.create \"GenerateDocs\" (fun _ ->\r\n          Shell.cleanDir \".fsdocs\"\r\n          DotNet.exec id \"fsdocs\" \"build --clean\" |> ignore\r\n       )\r\n\r\n7. Consider creating `docs\\_template.fsx` and `docs\\_template.ipynb` to enable co-generation of F# scripts and F# notebooks.\r\n\r\n   If you add support for notebooks and scripts, consider adding mybinder links to each of your literate executable content pages. [For example like this](https://github.com/fsprojects/FSharp.Formatting/blob/master/docs/literate.fsx#L19).\r\n\r\n   Also add load sections to make sure your notebooks and scripts contain the right content to load packages out of repo.  [For example like this](https://github.com/fsprojects/FSharp.Formatting/blob/master/docs/literate.fsx#L1)\r\n\r\nSample commands: \r\n\r\n    [lang=text]\r\n    dotnet tool install FSharp.Formatting.CommandTool --local\r\n    git add dotnet-tools.json   \r\n    git rm -fr docs/tools\r\n    git mv docs/input/* docs\r\n    git mv docs/files/* docs\r\n    \r\n    <manually download and fixup the _template.html>\r\n\r\n    dotnet fsdocs watch\r\n\r\n    touch docs/_template.fsx\r\n    touch docs/_template.ipynb\r\n    git add docs/_template.fsx\r\n    git add docs/_template.ipynb\r\n\r\nHere is an example PR: https://github.com/fsprojects/FSharp.Control.AsyncSeq/pull/116\r\n\r\n"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\sidebyside\\sideextensions.html","title":"Markdown extensions side-by-side example\r\n","content":"Markdown extensions side-by-side example\r\n===================\r\n\r\nTo use LaTex extension, you need add javascript\r\nlink to [MathJax](http://www.mathjax.org/) in\r\nyour template.\r\n\r\nTo use inline LaTex, eclose LaTex code with `$`:\r\n$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $. Alternatively,\r\nyou can also use `$$`.\r\n\r\nTo use block LaTex, start a new parapgraph, with\r\nthe first line marked as `$$$` (no close `$$$`):\r\n\r\n$$$\r\nA_{m,n} =\r\n \\begin{pmatrix}\r\n  a_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\\r\n  a_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\\r\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\r\n  a_{m,1} & a_{m,2} & \\cdots & a_{m,n}\r\n \\end{pmatrix}\r\n\r\nUse LaTex escape rule:\r\n\r\n- Escape \\$ in inline mode: $ \\$ $, $ \\$var $\r\n- Other escapes: $ \\& \\% \\$ \\# \\_ \\{ \\} $\r\n- Using < or >: $ x > 1 $, $ y < 1 $, $ x >= 1 $,\r\n  $ y <= 1 $, $ x = 1 $\r\n- $ <p>something</p> $\r\n\r\n\r\n"},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\sidebyside\\sidemarkdown.html","title":"Literate Markdown side-by-side example\r\n","content":"# Literate Markdown side-by-side example\r\n\r\nThis file demonstrates how to write Markdown document with \r\nembedded F# snippets that can be transformed into nice HTML \r\nusing the `literate.fsx` script from the [F# Formatting\r\npackage](http://fsprojects.github.io/FSharp.Formatting).\r\n\r\nIn this case, the document itself is a valid Markdown and \r\nyou can use standard Markdown features to format the text:\r\n\r\n - Here is an example of unordered list and...\r\n - Text formatting including **bold** and _emphasis_\r\n\r\nFor more information, see the [Markdown][md] reference.\r\n\r\n [md]: http://daringfireball.net/projects/markdown\r\n\r\n\r\n## Writing F# code\r\n\r\nIn standard Markdown, you can include code snippets by \r\nwriting a block indented by four spaces and the code \r\nsnippet will be turned into a `<pre>` element. If you do \r\nthe same using Literate F# tool, the code is turned into\r\na nicely formatted F# snippet:\r\n\r\n    /// The Hello World of functional languages!\r\n    let rec factorial x = \r\n      if x = 0 then 1 \r\n      else x * (factorial (x - 1))\r\n\r\n    let f10 = factorial 10\r\n\r\n\r\n## Hiding code\r\n\r\nIf you want to include some code in the source code, \r\nbut omit it from the output, you can use the `hide` \r\ncommand. You can also use `module=...` to specify that \r\nthe snippet should be placed in a separate module \r\n(e.g. to avoid duplicate definitions).\r\n\r\n    [hide, module=Hidden]\r\n    /// This is a hidden answer\r\n    let answer = 42\r\n\r\nThe value will be deffined in the F# code that is \r\nprocessed and so you can use it from other (visible) \r\ncode and get correct tool tips:\r\n\r\n    let answer = Hidden.answer\r\n\r\n\r\n## Including other snippets\r\n\r\nWhen writing literate programs as Markdown documents, \r\nyou can also include snippets in other languages. \r\nThese will not be colorized and processed as F# \r\ncode samples:\r\n\r\n    [lang=csharp]\r\n    Console.WriteLine(\"Hello world!\");\r\n\r\nThis snippet is turned into a `pre` element with the\r\n`lang` attribute set to `csharp`."},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\sidebyside\\sidescript.html","title":"Literate script side-by-side example\r\n","content":"(**\n# Literate script side-by-side example\n\nThis file demonstrates how to write literate F# script\nfiles (`*.fsx`) that can be transformed into nice HTML\nusing the `literate.fsx` script from the [F# Formatting\npackage](http://fsprojects.github.io/FSharp.Formatting).\n\nAs you can see, a comment starting with double asterisk\nis treated as part of the document and is transformed \nusing Markdown, which means that you can use:\n\n - Unordered or ordered lists \n - Text formatting including **bold** and _emphasis_\n\nAnd numerous other [Markdown][md] features.\n\n [md]: http://daringfireball.net/projects/markdown\n\n## Writing F# code\n\nCode that is not inside comment will be formatted as\na sample snippet.\n*)\n\n/// The Hello World of functional languages!\nlet rec factorial x = \n  if x = 0 then 1 \n  else x * (factorial (x - 1))\n\nlet f10 = factorial 10\n\n(**\nHiding code\n-----------\n\nIf you want to include some code in the source code, \nbut omit it from the output, you can use the `hide` \ncommand.\n*)\n\n(*** hide ***)\n/// This is a hidden answer\nlet hidden = 42\n\n(** \nThe value will be defined in the F# code and so you\ncan use it from other (visible) code and get correct\ntool tips:\n*)\n\nlet answer = hidden\n\n(** \n## Moving code around\n\nSometimes, it is useful to first explain some code that\nhas to be located at the end of the snippet (perhaps \nbecause it uses some definitions discussed in the middle).\nThis can be done using `include` and `define` commands.\n\nThe following snippet gets correct tool tips, even though\nit uses `laterFunction`:\n*)\n\n(*** include:later-bit ***)\n\n(**\nThen we can explain how `laterFunction` is defined:\n*)\n\nlet laterFunction() = \n  \"Not very difficult, is it?\"\n\n(**\nThis example covers pretty much all features that are \ncurrently implemented in `literate.fsx`, but feel free \nto [fork the project on GitHub][fs] and add more \nfeatures or report bugs!\n\n  [fs]: https://github.com/fsprojects/FSharp.Formatting\n\n*)\n\n(*** define:later-bit ***)\nlet sample = \n  laterFunction()\n  |> printfn \"Got: %s\""},{"uri":"https://fsprojects.github.io/FSharp.Formatting/.\\templates\\leftside\\styling.html","title":"Styling: Left-Side Example\r\n","content":"\r\nStyling: Left-Side Example\r\n==================================\r\n\r\nThe sidebar can be moved to the left by using \r\n\r\n   `<FsDocsNavbarPosition>fixed-left<FsDocsNavbarPosition>`\n   \nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\r\n\r\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\r\n\r\n"}]